package root;

import expressions.*;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.URL;
import java.util.*;
import java.util.ArrayList;

/*
 * MathFrame.java
 *
 * Created on 27 decembre 2002, 13:55
 * the code source is distributed under the GPL.
 * Please see http://www.fsf.org/copyleft/gpl.html
 */
/**
 * @author Patrice Maupou
 */
public class MathFrame extends java.awt.Frame {

    /**
     * Creates new form MathFrame
     */
    public MathFrame() {
        initComponents();
        fileName = "*.html";
        extension = "*.html";
        fileDialog = new FileDialog(this);
        fileDialog.pack();
        definitions = new ArrayList<Expression>();
        comments = new ArrayList<Expression>();
        decorations = new ArrayList<Expression>();
        imports = new ArrayList<Expression>();
        errorDialog = new MathDialog(this);
        String[] types_param = {"définitions globales", "définitions", "vérifications",
            "titre", "contexte", "énoncé", "commentaires", "décorations", "imports"};
        for (String types_param1 : types_param) {
            choiceParam.add(types_param1);
        }
        typedefs = 0;
        part = -1;
        enter.requestFocus();
    }

    public MathFrame(ExpressionApplet applet, boolean hide) {
        this();
        this.hide = hide;
        int width = 556, height = (hide) ? 557 - panelNorth.getHeight() : 557;
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width - width) / 2, (screenSize.height - height) / 2, width, height);
        if (hide) {
            remove(panelEnter);
            remove(panelNorth);
            menuBar.remove(actions);
            menuBar.remove(rules);
            files.remove(New);
            files.remove(export);
            files.remove(save);
            files.remove(merge);
            setResizable(false);
        }
        this.applet = applet;
        // modification pour les initialisations
        try {
            String dir = "file:\\" + System.getProperty("user.dir");
            getImportDefs(dir + "\\exercices\\definitions\\", "défaut.math");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;

    modesGroup = new java.awt.CheckboxGroup();
    panelEnter = new java.awt.Panel();
    enter = new java.awt.TextField();
    history = new java.awt.Choice();
    panelNorth = new java.awt.Panel();
    panelNorth.setPreferredSize(new Dimension(600, 150));
    panelRules = new java.awt.Panel();
    listRules = new java.awt.Label();
    choice = new java.awt.Choice();
    listLabels = new java.awt.Label();
    choiceFunctions = new java.awt.Choice();
    create = new java.awt.Checkbox();
    execute = new java.awt.Checkbox();
    param_name = new java.awt.Label();
    choiceParam = new java.awt.Choice();
    textArea = new java.awt.TextArea();
    textArea.setPreferredSize(new Dimension(600, 100));
    menuBar = new java.awt.MenuBar();
    files = new java.awt.Menu();
    New = new java.awt.MenuItem();
    open = new java.awt.MenuItem();
    save = new java.awt.MenuItem();
    merge = new java.awt.MenuItem();
    export = new java.awt.MenuItem();
    quit = new java.awt.MenuItem();
    rules = new java.awt.Menu();
    menuAdd = new java.awt.Menu();
    menuAddDef = new java.awt.MenuItem();
    menuAddRule = new java.awt.MenuItem();
    menuAddExercise = new java.awt.MenuItem();
    menuAddPartie = new java.awt.MenuItem();
    menuDelete = new java.awt.MenuItem();
    menuRuleModify = new java.awt.MenuItem();
    menuExtractDef = new java.awt.MenuItem();
    actions = new java.awt.Menu();
    menuCompute = new java.awt.MenuItem();
    menuReplace = new java.awt.MenuItem();
    menuInitialize = new java.awt.MenuItem();
    menuApply = new java.awt.Menu();
    menuApplyDef = new java.awt.MenuItem();
    menuApplyDefs = new java.awt.MenuItem();
    menuParts = new java.awt.Menu();
    menuPrevious = new java.awt.MenuItem();
    menuNext = new java.awt.MenuItem();
    cheatMenu = new java.awt.CheckboxMenuItem();
    debugMenu = new java.awt.CheckboxMenuItem();
    enterGPanel = new java.awt.CheckboxMenuItem();
    infos = new java.awt.Menu();
    palette = new java.awt.MenuItem();
    aide = new java.awt.MenuItem();
    about = new java.awt.MenuItem();

    modesGroup.setSelectedCheckbox(create);

    setFont(new java.awt.Font("Dialog", 0, 11)); // NOI18N
    setTitle("Mathoscope");
    addWindowListener(new java.awt.event.WindowAdapter() {
      public void windowClosing(java.awt.event.WindowEvent evt) {
        exitForm(evt);
      }
    });
    addComponentListener(new java.awt.event.ComponentAdapter() {
      public void componentResized(java.awt.event.ComponentEvent evt) {
        formComponentResized(evt);
      }
    });

    panelEnter.setLayout(new java.awt.GridLayout(2, 0));

    enter.setFont(new java.awt.Font("Dialog", 0, 14));
    enter.addKeyListener(new java.awt.event.KeyAdapter() {
      public void keyPressed(java.awt.event.KeyEvent evt) {
        enterKeyPressed(evt);
      }
    });
    enter.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        enterActionPerformed(evt);
      }
    });
    panelEnter.add(enter);

    history.setFont(new java.awt.Font("Dialog", 0, 11));
    history.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        historyItemStateChanged(evt);
      }
    });
    history.addKeyListener(new java.awt.event.KeyAdapter() {
      public void keyPressed(java.awt.event.KeyEvent evt) {
        historyKeyPressed(evt);
      }
    });
    panelEnter.add(history);

    add(panelEnter, java.awt.BorderLayout.SOUTH);

    panelNorth.setLayout(new javax.swing.BoxLayout(panelNorth, javax.swing.BoxLayout.Y_AXIS));

    panelRules.setLayout(new java.awt.GridBagLayout());

    listRules.setAlignment(java.awt.Label.CENTER);
    listRules.setText("                    ");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.weighty = 0.3;
    panelRules.add(listRules, gridBagConstraints);

    choice.setFont(new java.awt.Font("Dialog", 0, 11));
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.gridwidth = 3;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.weightx = 2.0;
    gridBagConstraints.weighty = 0.3;
    panelRules.add(choice, gridBagConstraints);

    listLabels.setFont(new java.awt.Font("Dialog", 0, 11));
    listLabels.setText("Noms :");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 4;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.weightx = 0.1;
    gridBagConstraints.weighty = 0.3;
    panelRules.add(listLabels, gridBagConstraints);

    choiceFunctions.setFont(new java.awt.Font("Dialog", 0, 11));
    choiceFunctions.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        choiceFunctionsItemStateChanged(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 5;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 0.3;
    panelRules.add(choiceFunctions, gridBagConstraints);

    create.setCheckboxGroup(modesGroup);
    create.setFont(new java.awt.Font("Dialog", 0, 11));
    create.setLabel("Créer");
    create.setState(true);
    create.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        modeChanged(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 3;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.ipadx = 15;
    gridBagConstraints.weighty = 0.3;
    panelRules.add(create, gridBagConstraints);

    execute.setCheckboxGroup(modesGroup);
    execute.setFont(new java.awt.Font("Dialog", 0, 11));
    execute.setLabel("Exécuter");
    execute.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        modeChanged(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 5;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.weighty = 0.3;
    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
    panelRules.add(execute, gridBagConstraints);

    param_name.setFont(new java.awt.Font("Dialog", 0, 11));
    param_name.setText("Paramètres :");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.weighty = 0.3;
    panelRules.add(param_name, gridBagConstraints);

    choiceParam.setFont(new java.awt.Font("Dialog", 0, 11));
    choiceParam.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        choiceParamItemStateChanged(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.weightx = 0.1;
    gridBagConstraints.weighty = 0.3;
    panelRules.add(choiceParam, gridBagConstraints);

    panelNorth.add(panelRules);

    textArea.setFont(new java.awt.Font("Dialog", 0, 11));
    textArea.setRows(4);
    textArea.addFocusListener(new java.awt.event.FocusAdapter() {
      public void focusLost(java.awt.event.FocusEvent evt) {
        textAreaFocusLost(evt);
      }
    });
    panelNorth.add(textArea);

    add(panelNorth, java.awt.BorderLayout.NORTH);

    menuBar.setFont(new java.awt.Font("Dialog", 0, 11));

    files.setFont(new java.awt.Font("Dialog", 0, 11));
    files.setLabel("Fichiers");

    New.setFont(new java.awt.Font("Dialog", 0, 11));
    New.setLabel("Nouveau");
    New.setShortcut(new MenuShortcut(KeyEvent.VK_N,false));
    New.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        NewActionPerformed(evt);
      }
    });
    files.add(New);

    open.setActionCommand("Charger les règles");
    open.setFont(new java.awt.Font("Dialog", 0, 11));
    open.setLabel("Ouvrir");
    open.setShortcut(new MenuShortcut(KeyEvent.VK_O,false));
    open.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        openActionPerformed(evt);
      }
    });
    files.add(open);

    save.setActionCommand("Enregistrer les règles");
    save.setFont(new java.awt.Font("Dialog", 0, 11));
    save.setLabel("Enregistrer");
    save.setShortcut(new MenuShortcut(KeyEvent.VK_S,false));
    save.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        saveActionPerformed(evt);
      }
    });
    files.add(save);

    merge.setActionCommand("Charger les règles");
    merge.setFont(new java.awt.Font("Dialog", 0, 11));
    merge.setLabel("Importer des définitions");
    merge.setShortcut(new MenuShortcut(KeyEvent.VK_I,false));
    merge.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        openActionPerformed(evt);
      }
    });
    files.add(merge);

    export.setFont(new java.awt.Font("Dialog", 0, 11));
    export.setLabel("Exporter des définitions");
    export.setShortcut(new MenuShortcut(KeyEvent.VK_S,true));
    export.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        saveActionPerformed(evt);
      }
    });
    files.add(export);

    quit.setFont(new java.awt.Font("Dialog", 0, 11));
    quit.setLabel("Quitter");
    quit.setShortcut(new MenuShortcut(KeyEvent.VK_Q, false));
    quit.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        quitActionPerformed(evt);
      }
    });
    files.add(quit);

    menuBar.add(files);

    rules.setFont(new java.awt.Font("Dialog", 0, 11));
    rules.setLabel("Définitions");

    menuAdd.setFont(new java.awt.Font("Dialog", 0, 11));
    menuAdd.setLabel("Ajouter");

    menuAddDef.setFont(new java.awt.Font("Dialog", 0, 11));
    menuAddDef.setLabel("une définition");
    menuAddDef.setShortcut(new MenuShortcut(KeyEvent.VK_D, false));
    menuAddDef.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuAddDefActionPerformed(evt);
      }
    });
    menuAdd.add(menuAddDef);

    menuAddRule.setFont(new java.awt.Font("Dialog", 0, 11));
    menuAddRule.setLabel("une règle");
    menuAddRule.setShortcut(new MenuShortcut(KeyEvent.VK_R,false));
    menuAddRule.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuAddRuleActionPerformed(evt);
      }
    });
    menuAdd.add(menuAddRule);

    menuAddExercise.setFont(new java.awt.Font("Dialog", 0, 11));
    menuAddExercise.setLabel("un exercice");
    menuAddExercise.setShortcut(new MenuShortcut(KeyEvent.VK_X, true));
    menuAddExercise.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuAddExerciseActionPerformed(evt);
      }
    });
    menuAdd.add(menuAddExercise);

    menuAddPartie.setFont(new java.awt.Font("Dialog", 0, 11));
    menuAddPartie.setLabel("une question");
    menuAddPartie.setShortcut(new MenuShortcut(KeyEvent.VK_Q, true));
    menuAddPartie.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuAddPartieActionPerformed(evt);
      }
    });
    menuAdd.add(menuAddPartie);

    rules.add(menuAdd);

    menuDelete.setFont(new java.awt.Font("Dialog", 0, 11));
    menuDelete.setLabel("Supprimer");
    menuDelete.setShortcut(new MenuShortcut(KeyEvent.VK_DELETE, false));
    menuDelete.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuDeleteActionPerformed(evt);
      }
    });
    rules.add(menuDelete);

    menuRuleModify.setFont(new java.awt.Font("Dialog", 0, 11));
    menuRuleModify.setLabel("Extraire une règle");
    menuRuleModify.setShortcut(new MenuShortcut(KeyEvent.VK_T, false));
    menuRuleModify.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuExtractActionPerformed(evt);
      }
    });
    rules.add(menuRuleModify);

    menuExtractDef.setLabel("Extraire une définition");
    menuExtractDef.setShortcut(new MenuShortcut(KeyEvent.VK_T, true));
    menuExtractDef.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuExtractActionPerformed(evt);
      }
    });
    rules.add(menuExtractDef);

    menuBar.add(rules);

    actions.setFont(new java.awt.Font("Dialog", 0, 11));
    actions.setLabel("Actions");

    menuCompute.setFont(new java.awt.Font("Dialog", 0, 11));
    menuCompute.setLabel("Calculer");
    menuCompute.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuComputeActionPerformed(evt);
      }
    });
    actions.add(menuCompute);

    menuReplace.setFont(new java.awt.Font("Dialog", 0, 11));
    menuReplace.setLabel("Remplacer une expression");
    menuReplace.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuReplaceActionPerformed(evt);
      }
    });
    actions.add(menuReplace);

    menuInitialize.setFont(new java.awt.Font("Dialog", 0, 11));
    menuInitialize.setLabel("Initialiser les variables");
    menuInitialize.setShortcut(new MenuShortcut(KeyEvent.VK_I,true));
    menuInitialize.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuInitializeActionPerformed(evt);
      }
    });
    actions.add(menuInitialize);

    menuApply.setFont(new java.awt.Font("Dialog", 0, 11));
    menuApply.setLabel("Appliquer");

    menuApplyDef.setFont(new java.awt.Font("Dialog", 0, 11));
    menuApplyDef.setLabel("une fonction ou un schéma");
    menuApplyDef.setShortcut(new MenuShortcut(KeyEvent.VK_F, false));
    menuApplyDef.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuDefApplyActionPerformed(evt);
      }
    });
    menuApply.add(menuApplyDef);

    menuApplyDefs.setFont(new java.awt.Font("Dialog", 0, 11));
    menuApplyDefs.setLabel("les définitions des variables");
    menuApplyDefs.setShortcut(new MenuShortcut(KeyEvent.VK_D,true));
    menuApplyDefs.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        menuApplyDefsActionPerformed(evt);
      }
    });
    menuApply.add(menuApplyDefs);

    actions.add(menuApply);

    menuParts.setFont(new java.awt.Font("Dialog", 0, 11));
    menuParts.setLabel("Question");

    menuPrevious.setFont(new java.awt.Font("Dialog", 0, 11));
    menuPrevious.setLabel("précédente");
    menuPrevious.setShortcut(new MenuShortcut(KeyEvent.VK_LESS,false));
    menuPrevious.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        PartNavigate(evt);
      }
    });
    menuParts.add(menuPrevious);

    menuNext.setFont(new java.awt.Font("Dialog", 0, 11));
    menuNext.setLabel("suivante");
    menuNext.setShortcut(new MenuShortcut(KeyEvent.VK_LESS,true));
    menuNext.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        PartNavigate(evt);
      }
    });
    menuParts.add(menuNext);

    actions.add(menuParts);

    cheatMenu.setFont(new java.awt.Font("Dialog", 0, 11));
    cheatMenu.setLabel("Mode test");
    cheatMenu.setShortcut(new MenuShortcut(KeyEvent.VK_F1,false));
    cheatMenu.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        cheatMenuItemStateChanged(evt);
      }
    });
    actions.add(cheatMenu);

    debugMenu.setFont(new java.awt.Font("Dialog", 0, 11));
    debugMenu.setLabel("Mode debug");
    debugMenu.setShortcut(new MenuShortcut(KeyEvent.VK_F2,false));
    debugMenu.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        debugMenuItemStateChanged(evt);
      }
    });
    actions.add(debugMenu);

    enterGPanel.setFont(new java.awt.Font("Dialog", 0, 11));
    enterGPanel.setLabel("Entrée directe");
    enterGPanel.setShortcut(new MenuShortcut(KeyEvent.VK_P,false));
    enterGPanel.addItemListener(new java.awt.event.ItemListener() {
      public void itemStateChanged(java.awt.event.ItemEvent evt) {
        enterGPanelItemStateChanged(evt);
      }
    });
    actions.add(enterGPanel);

    menuBar.add(actions);

    infos.setFont(new java.awt.Font("Dialog", 0, 11));
    infos.setLabel("Infos");

    palette.setFont(new java.awt.Font("Dialog", 0, 11));
    palette.setLabel("palette de symboles");
    palette.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        paletteActionPerformed(evt);
      }
    });
    infos.add(palette);

    aide.setFont(new java.awt.Font("Dialog", 0, 11));
    aide.setLabel("Aide");
    infos.add(aide);

    about.setFont(new java.awt.Font("Dialog", 0, 11));
    about.setLabel("A propos");
    about.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        aboutActionPerformed(evt);
      }
    });
    infos.add(about);

    menuBar.add(infos);

    setMenuBar(menuBar);

    java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
    setBounds((screenSize.width-556)/2, (screenSize.height-557)/2, 556, 557);
  }// </editor-fold>//GEN-END:initComponents

  private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
      if (applet != null) {
          applet.GPanel.updateImg();
          applet.GPanel.repaint();
          applet.GPanel.drawFig(applet.Gobjets, 0, -1);
      }
  }//GEN-LAST:event_formComponentResized

  private void paletteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_paletteActionPerformed
      applet.showTools(20, 20);
  }//GEN-LAST:event_paletteActionPerformed

  private void textAreaFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_textAreaFocusLost
      if (!evt.isTemporary()) {
          String txt = Parser.replace(textArea.getText(), "\n", "¶");
          String param = choiceParam.getSelectedItem();
          if ("commentaires".equals(param)) {
              String item = choiceFunctions.getSelectedItem();
              StringTokenizer tk = new StringTokenizer(item, "(");
              Expression f = Expression.var(tk.nextToken());
              int i = comments.indexOf(f);
              if (i != -1) {
                  f = comments.get(i);
              } else {
                  comments.add(f);
              }
              f.R = Expression.var(txt);
              try {
                  updateChoiceDefs(item, -1, 0);
              } catch (Exception e) {
              }
              textArea.setText(saveText);
          } else if ("énoncé".equals(param) && applet.Partie > -1) {
              applet.params = applet.getParameters().get(applet.Partie);
              applet.params[ExpressionApplet.INTRO] = Parser.replace(txt, "\n", "¶");
              updatePart();
          }
      }
  }//GEN-LAST:event_textAreaFocusLost

  private void menuDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuDeleteActionPerformed
      errorDialog.setTitle("Avertissement");
      errorDialog.setButtonsVisible(true);
      if (choiceFunctions.hasFocus()) {
          errorDialog.setLabel("Supprimer la définition ?");
          errorDialog.setVisible(true);
          if (!errorDialog.isAnswer()) {
              return;
          }
          int idx = choiceParam.getSelectedIndex();
          switch (idx) {
              case GDEFS:
              case DEFS:
              case CHECKS:
              case DECOS:
                  try {
                      StringTokenizer tk = new StringTokenizer(choiceFunctions.getSelectedItem(), "(");
                      Expression def = Expression.var(tk.nextToken());
                      idx = choiceParam.getSelectedIndex();
                      int n = choiceFunctions.getSelectedIndex();
                      String pre = (n <= 0) ? "" : choiceFunctions.getItem(n - 1);
                      if (idx == GDEFS) {
                          int globalsize = applet.getCnt_create()[0];
                          updateChoiceDefs(removeDefinition(n, -1, pre), -1, idx);
                          applet.updateDefinitions(definitions, globalsize);
                          applet.setDecorations(decorations);
                          if ((idx = comments.indexOf(def)) != -1) {
                              comments.remove(idx);
                          }
                      } else if (idx == DECOS) {
                          if (n > -1) {
                              decorations.remove(n);
                          }
                          updateChoiceDefs("", -1, DECOS);
                      } else { // DEFS ou CHECKS
                          int p = applet.getPartie();
                          updateChoiceDefs(removeDefinition(n, 2 * p + idx - 1, pre), p, idx);
                      }
                      if (idx == GDEFS || idx == DECOS) {
                          applet.setDecorations(decorations);
                      }
                  } catch (Exception exc) {
                      textArea.setText(" Erreur de suppression : " + exc.toString());
                  }
                  updatePart();
                  break;
              case IMPORTS:
                  String s = choiceFunctions.getSelectedItem();
                  Expression deffile = Expression.var(s);
                  boolean found = imports.remove(deffile);
                  if (found) {
                      choiceFunctions.remove(s);
                  }
                  break;
              case TITLE: // suppression titre et exercice correspondant
                  errorDialog.setLabel("Supprimer l'exercice ?");
                  errorDialog.setVisible(true);
                  if (!errorDialog.isAnswer()) {
                      return;
                  }
                  int rang = applet.getNumero();
                  if (rang != -1) {
                      int nb = applet.getExercices().length;
                      String[] exercices = new String[nb - 1];
                      System.arraycopy(applet.getExercices(), 0, exercices, 0, rang);
                      System.arraycopy(applet.getExercices(), rang + 1, exercices, rang, nb - rang - 1);
                      applet.setExercices(exercices);
                      choiceFunctions.remove(choiceFunctions.getSelectedIndex());
                      applet.initGraph(null);
                      applet.loadExercices(exercices, "Exercice supprimé", "", "");
                  }
                  break;
          }
      } else if (choice.hasFocus()) { // supprimer une règle
          String name = choiceFunctions.getSelectedItem();
          int n = name.indexOf('(');
          if (n != -1) {
              name = name.substring(0, n);
          }
          Expression def = Expression.var(name);
          int idx = choiceParam.getSelectedIndex();
          AbstractList<Expression> curDefs = (idx == 7) ? decorations : definitions;
          int p = (idx % 7 == 0) ? 0 : applet.getCnt_create()[2 * part + idx - 1];
          n = curDefs.subList(p, curDefs.size()).indexOf(def);
          if (n == -1) {
              return;
          }
          def = (Expression) ((Expression) curDefs.get(n + p)).R;
          if (def.op == Expression.EQU) {// f(x) = applique(..) ou f(x) = 2+x
              def = (Expression) def.R;
              if (!"applique".equals(def.L)) {
                  def = (Expression) def.L;
              }
          }
          try {
              choice.remove(choice.getSelectedIndex());
              def.R = setRules();
          } catch (Exception e) {
              textArea.setText(" Erreurs dans les règles");
          }
          if (idx == 1 || idx == 2) {
              updatePart();
          } else if (idx == 0 || idx == 7) {
              applet.updateDefinitions(definitions, applet.getCnt_create()[0]);
              applet.setDecorations(decorations);
          }
          updatePart();
      } else if (history.hasFocus()) {
          history.remove(history.getSelectedItem());
      } else if (enter.hasFocus()) {
          enter.setText("");
      }
  }//GEN-LAST:event_menuDeleteActionPerformed

  private void enterGPanelItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_enterGPanelItemStateChanged
      if (applet.GPanelActive = (evt.getStateChange() == ItemEvent.SELECTED)) {
          textArea.setText("Entrer une expression au clavier");
          if (applet.Partie != -1) {
              applet.Partie = -1;
              applet.tutorial = false;
              applet.runner = null;
              applet.GPanel.updateImg();
              applet.definitions.subList(applet.getCnt_create()[0], definitions.size()).clear();
          }
          applet.active.parent = Expression.NULL;
          applet.active.place = -4;
          applet.root = applet.active;
          applet.drawExpression(applet.root, 0, 0, false);
          applet.GPanel.requestFocus();
          applet.activerange = applet.Gobjets.size() - 1;
          if (applet.runner == null) {
              applet.runner = new Thread(applet);
              applet.runner.start();
          }
      } else { // pas d'activité
          applet.runner = null;
          applet.initGraph(null);
      }
  }//GEN-LAST:event_enterGPanelItemStateChanged

  private void debugMenuItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_debugMenuItemStateChanged
      trace = (evt.getStateChange() == ItemEvent.SELECTED) ? new ArrayList<Expression>() : null;
  }//GEN-LAST:event_debugMenuItemStateChanged

  private void cheatMenuItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_cheatMenuItemStateChanged
      applet.demo = !applet.demo;
      applet.initExercise();
  }//GEN-LAST:event_cheatMenuItemStateChanged

  private void PartNavigate(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PartNavigate
      if (status) {
          errorDialog.setLabel("seulement en mode création");
          errorDialog.setVisible(true);
          return;
      }
      if (evt.getSource() == menuNext && part > -1 && part < applet.getPartie()) {
          part++;
      } else if (evt.getSource() == menuPrevious && part > 0) {
          part--;
      } else {
          return;
      }
      try {
          updateChoiceDefs("", part, 1);
      } catch (Exception exc) {
          exc.toString();
      }
  }//GEN-LAST:event_PartNavigate

  private void NewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NewActionPerformed
      choice.removeAll();
      choiceFunctions.removeAll();
      history.removeAll();
      definitions = new ArrayList<Expression>();
      decorations = new ArrayList<Expression>();
      imports = new ArrayList<Expression>();
      htmlDir = null;
      applet.reset();
      textArea.setText("");
      setTitle("Mathoscope");
      applet.symbols.subList(applet.symbsize, applet.symbols.size()).clear();
      applet.setTools();
  }//GEN-LAST:event_NewActionPerformed

  private void menuAddPartieActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuAddPartieActionPerformed
      // on ajoute une question à l'exercice
      if (status) {
          errorDialog.setLabel("seulement en mode création");
          errorDialog.setVisible(true);
          return;
      }
      int rg = applet.getPartie(), num = applet.getNumero();
      String[] params = applet.getParameters().get(rg);
      StringTokenizer tk = new StringTokenizer(params[ExpressionApplet.MARKS]);
      tk.nextToken();
      int start = Integer.parseInt(tk.nextToken()), end = start + 38;
      String[] elems = {"", "définitions :~", "vérification :~", start + " " + end};
      try {
          applet.getParameters().add(rg + 1, elems);
      } catch (ArrayIndexOutOfBoundsException ABE) {
          return;
      }
      int n = applet.getCnt_create().length;
      int[] newCnt = new int[n + 2]; // taille +2
      System.arraycopy(applet.getCnt_create(), 0, newCnt, 0, 2 * rg + 3);
      System.arraycopy(applet.getCnt_create(), 2 * rg + 3, newCnt, 2 * rg + 5, n - 2 * rg - 3);
      newCnt[2 * rg + 3] = newCnt[2 * rg + 2];
      newCnt[2 * rg + 4] = newCnt[2 * rg + 2];
      applet.setPartie(rg + 1);
      applet.setCnt_create(newCnt);
      try {
          updateChoiceDefs("", applet.getPartie(), 1);
          textArea.setText("(Ecrire l'énoncé de la question)");
          textArea.selectAll();
          textArea.requestFocus();
          choiceParam.select("énoncé");
      } catch (Exception exc) {
          textArea.setText(" Echec dans l'ajout d'une partie : " + exc.toString());
      }
  }//GEN-LAST:event_menuAddPartieActionPerformed

    /**
     * bascule entre mode création et exécution
     */
  private void modeChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_modeChanged
      status = modesGroup.getSelectedCheckbox() == execute;
      try {
          typedefs = choiceParam.getSelectedIndex();
          part = applet.getPartie();
          updateChoiceDefs(choiceFunctions.getSelectedItem(), part, typedefs);
      } catch (Exception exc) {
          textArea.setText("définitions non disponibles");
      }
  }//GEN-LAST:event_modeChanged

    /**
     * actualise les boîtes de définitions et de règles
     *
     * @param evt
     */
  private void choiceParamItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_choiceParamItemStateChanged
      int index = choiceParam.getSelectedIndex();
      String item = choiceFunctions.getSelectedItem(); // TODO : réécrire en utilisant seulement l'index
      choiceFunctions.removeAll();
      choice.removeAll();
      try {
          if (index < 3) {
              int p = (status) ? applet.getPartie() : part;
              updateChoiceDefs("", p, index);
          } else if (choiceParam.getSelectedItem().equals("titre")) {
              choiceFunctions.add(applet.getTitle());
          } else if (choiceParam.getSelectedItem().equals("total")) {
              choiceFunctions.add("" + 20);
          } else if (choiceParam.getSelectedItem().equals("commentaires")) {
              updateChoiceDefs(item, 0, COMMENTS);
              saveText = textArea.getText().replace('¶', '\n');
              StringTokenizer tk = new StringTokenizer(item, "(");
              String s = "";
              Expression f = Expression.var(tk.nextToken());
              if ((index = comments.indexOf(f)) != -1) {
                  f = comments.get(index);
                  f = (Expression) f.R;
                  s = (String) f.L;
              }
              textArea.setText(s.replace('¶', '\n'));
              textArea.requestFocus();
          } else if (choiceParam.getSelectedItem().equals("décorations")) {
              updateChoiceDefs("", -1, DECOS);
          } else if (choiceParam.getSelectedItem().equals("imports")) {
              updateChoiceDefs("", -1, IMPORTS);
          }
      } catch (Exception exc) {
          textArea.setText(" Errreur dans les " + choiceParam.getSelectedItem());
      }
  }//GEN-LAST:event_choiceParamItemStateChanged

  private void historyKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_historyKeyPressed
      if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
          enter.requestFocus();
      }
  }//GEN-LAST:event_historyKeyPressed

  private void menuAddExerciseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuAddExerciseActionPerformed
      int n = applet.getExercices().length + 1;
      String[] exercices = new String[n];
      System.arraycopy(applet.getExercices(), 0, exercices, 0, n - 1);
      String title = "exercice " + n;
      if ("titre".equals(choiceParam.getSelectedItem())) {
          title = enter.getText();
      }
      choiceFunctions.removeAll();
      choiceFunctions.add(title);
      exercices[n - 1] = "titre : " + title + "~nombre de questions : 20~"
              + "énoncé : " + textArea.getText().replace('\r', '¶') + "~définitions :~vérifications :~";
      applet.setExercices(exercices);
      applet.setTitle(title, false); // on ajoute un titre à la boîte
      applet.setPartie(0); // définitions
      textArea.setText("(Ecrire l'énoncé de la question)");
      textArea.selectAll();
      textArea.requestFocus();
      choiceParam.select("énoncé");
      applet.initGraph(null);
  }//GEN-LAST:event_menuAddExerciseActionPerformed

    /**
     * pour chaque item de la boîte des définitions, choisit de nouveau les
     * variables ou les ajoute.
     *
     * @param evt le menu initialise les variables a été actionné
     */
  private void menuInitializeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuInitializeActionPerformed
      String alert = "";
      if (status) {
          alert = "seulement en mode création";
      } else if (applet.getPartie() != 0) {
          alert = "reprendre l'exercice au début";
      }
      if (!alert.equals("")) {
          errorDialog.setLabel(alert);
          errorDialog.setVisible(true);
          return;
      }
      if (applet.getPartie() != 0) {
          return;
      }
      try {
          Expression[] listdefs = (Expression[]) Parser.parse("{" + enter.getText() + "}").R;
          int index, start = applet.getCnt_create()[0];
          ArrayList<Expression> newdefs = new ArrayList<Expression>(), defs = applet.getDefinitions();
          for (int i = 0; i < start; i++) {
              newdefs.add(definitions.get(i));
          }
          for (Expression listdef : listdefs) {
              listdef.define(newdefs, true);
          }
          StringTokenizer tk = new StringTokenizer(choiceFunctions.getSelectedItem(), "(");
          String s = tk.nextToken();
          //index = definitions.indexOf(Expression.var(s), start)+1;
          index = definitions.subList(start, definitions.size()).indexOf(Expression.var(s)) + start + 1;
          if (index == 0) {
              index = start;
          }
          for (int i = index; i < applet.getCnt_create()[1]; i++) {
              newdefs.add(definitions.get(i));
          }
          for (int i = start; i < newdefs.size(); i++) {
              Expression def = newdefs.get(i);
              Expression name = Parser.parse((String) def.L);
              def = Expression.build(Expression.IS, name, def.R);
              def.define(defs, true);
          }
          updateChoiceDefs("", applet.getPartie(), 1);
          applet.display(true);
      } catch (Exception exc) {
          textArea.setText(" Erreur de réinitialisation : " + exc.toString());
      }

  }//GEN-LAST:event_menuInitializeActionPerformed

  private void menuApplyDefsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuApplyDefsActionPerformed
      int size = definitions.size();
      try {
          Expression e = Parser.parse(enter.getText());
          boolean isFigure = e.equals(Expression.var("figure"));
          e = e.applyDefs(definitions, 0, 50, trace);
          display(e, isFigure);
          textArea.setText(debug());
      } catch (Exception exc) {
          definitions.subList(size, definitions.size()).clear();
          if (trace != null) {
              textArea.setText("dépassement de pile " + exc.getMessage());
          } else {
              textArea.append("\ndépassement de pile " + exc.getMessage());
          }
      }
  }//GEN-LAST:event_menuApplyDefsActionPerformed

    /**
     * ajoute une règle à un schéma ou une fonction sélectionnée dans la boîte
     * de variables
     */
  private void menuAddRuleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuAddRuleActionPerformed
      Expression def, defR, edef, rule;
      int index = choiceParam.getSelectedIndex();
      AbstractList<Expression> curDefs = (index == 7) ? decorations : definitions;
      try {
          //rule = Parser.parse(enter.getText().trim());
          definition = choiceFunctions.getSelectedItem();
          int func = definition.indexOf('(');
          StringTokenizer tk = new StringTokenizer(definition, "(");
          def = Expression.build(Expression.VAR, tk.nextToken(), null);
          int n = curDefs.indexOf(def);
          if (n == -1) {
              throw new Exception("pas d'élément correspondant");
          }
          def = curDefs.get(n); // f->f(x)=.. ou f->schéma(..)
          defR = (Expression) def.R; // f(x) ou f(x)=applique(..) ou schéma(..)
          if ("figure".equals(def.L)) {
              n = choiceInsert(enter.getText().trim(), choice);
              Expression[] ruleslist = setRules();
              if (ruleslist.length == 1) {
                  def.R = ruleslist[0];
              } else {
                  def.R = Expression.build(Expression.SEQ, "v", ruleslist);
              }
          } else if ("schéma".equals(defR.L) || "applique".equals(defR.L) || func != -1) {
              n = choiceInsert(enter.getText().trim(), choice);
              Expression[] ruleslist = setRules();
              if (func != -1) {
                  if (defR.op == Expression.EQU) { // f(x)=applique(..) ou f(x)=x+1
                      defR = (Expression) defR.R; // applique(..) ou l'expression
                      if (!"applique".equals(defR.L) && !"schéma".equals(defR.L)) {
                          def.R = Expression.build(Expression.FUNC, defR.L, ruleslist); // TODO : corriger
                      } else {
                          defR.R = ruleslist;
                      }
                  } else {// une seule règle
                      rule = Expression.build(Expression.FUNC, "applique", ruleslist);
                      def.R = Expression.build(Expression.EQU, defR, rule);
                  }
              } else {
                  defR.R = ruleslist;
              }
          } else {
              n = choiceInsert(enter.getText().trim(), choice);
              def.R = Expression.build(Expression.SEQ, "v", setRules());
          }
          int p = (index == 0 || index == 7) ? 0 : applet.getCnt_create()[2 * part + index - 1];
          int m = curDefs.subList(p, curDefs.size()).indexOf(def) + p;
          if (m != -1) {
              edef = curDefs.get(m);
              edef.R = def.copy().R;
          }
          if (index == 1 || index == 2) {
              updatePart();
          } else if (index == 0) {
              applet.updateDefinitions(definitions, applet.getCnt_create()[0]);
          }
          if (history.getItemCount() > 0) {
              enter.setText(history.getItem(0));
          }
          if (index == 7 || index == 0) {
              applet.setDecorations(decorations);
          }
          choice.select(n);
      } catch (Exception exc) {
          textArea.setText(" Règle erronée : " + exc.getMessage());
      }
  }//GEN-LAST:event_menuAddRuleActionPerformed

    /**
     * ajoute ou remplace une définition dans la boîte de variables
     */
  private void menuAddDefActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuAddDefActionPerformed
      if (status) {
          errorDialog.setLabel("seulement en mode création");
          errorDialog.setVisible(true);
          return;
      }
      int index = choiceParam.getSelectedIndex();
      String pre = choiceFunctions.getSelectedItem();
      if (pre != null) {
          pre = (new StringTokenizer(pre, "(")).nextToken();
      }
      try {
          switch (index) {
              case GDEFS: // définitions globales
                  int globalsize = applet.getCnt_create()[0];
                  Expression def = Parser.parse(enter.getText().trim());
                  updateChoiceDefs(addDefinition(def, -1, pre), -1, 0);
                  applet.updateDefinitions(definitions, globalsize);
                  applet.setDecorations(decorations);
                  break;
              case DEFS: // définitions
              case CHECKS: // vérifications
                  int p = applet.getCnt_create()[2 * part + index - 1],
                   end = p;
                  if (pre != null) {
                      end = definitions.subList(p, definitions.size()).indexOf(Expression.var(pre)) + p + 1;
                  }
                  String listdefs = "{";
                  for (int i = applet.getCnt_create()[0]; i < end; i++) {
                      Expression nextdef = definitions.get(i), value = (Expression) nextdef.R;
                      try {
                          nextdef = Parser.parse((String) nextdef.L);
                      } catch (Exception ex) {
                      }
                      nextdef = Expression.build(Expression.IS, nextdef, value);
                      listdefs += nextdef.printout(false) + ",";
                  }
                  listdefs += enter.getText() + "}";
                  Expression[] defs = (Expression[]) Parser.parse(listdefs).R;
                  def = defs[defs.length - 1];
                  updateChoiceDefs(addDefinition(def, 2 * part + index - 1, pre), part, index);
                  updatePart();
                  break;
              case TITLE: // titres, on change le titre
                  String title = enter.getText();
                  choiceFunctions.removeAll();
                  choiceFunctions.add(title);
                  applet.setTitle(title, true); // on ajoute un titre à la boîte
                  int n = applet.getNumero();
                  try {
                      applet.getExercices()[n] = exerciceToString(n);
                  } catch (Exception exc) {
                      textArea.setText("exercice mal écrit");
                  }
                  break;
              case TOTAL: // nombre de questions
                  choiceFunctions.removeAll();
                  choiceFunctions.add(enter.getText());
                  n = applet.getNumero();
                  String textExo = applet.getExercices()[n];
                  int s = textExo.indexOf("nombre de questions :") + 22;
                  int e = textExo.indexOf("~", s);
                  textExo = textExo.substring(0, s) + 20 + textExo.substring(e);
                  applet.getExercices()[n] = textExo;
                  break;
              case DECOS: // affichages et decorations
                  def = Parser.parse(enter.getText().trim());
                  updateChoiceDefs(addDefinition(def, -7, pre), -1, 7);
                  applet.setDecorations(decorations);
                  break;
          }
      } catch (Exception exc) {
          textArea.setText("mauvaise définition : " + exc.toString());
      }
  }//GEN-LAST:event_menuAddDefActionPerformed

    /**
     * met à jour la définition dans la boîte
     */
  private void choiceFunctionsItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_choiceFunctionsItemStateChanged
      int n = choiceParam.getSelectedIndex();
      if (status && n < 7) {
          updateChoice(applet.getDefinitions());
      } else {
          if (n == 7) {
              updateChoice(decorations);
          } else if (n == 8) {
              updateChoice(imports);
          } else {
              updateChoice(definitions);
          }
      }
  }//GEN-LAST:event_choiceFunctionsItemStateChanged

    /**
     * Extrait une règle ou une définition
     */
  private void menuExtractActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuExtractActionPerformed
      if (evt.getSource() == menuExtractDef) {
          Expression var, def;
          int index = choiceParam.getSelectedIndex();
          if (index >= TITLE) {
              return;
          }
          int k = (index == GDEFS || index == COMMENTS || status) ? 0 : applet.getCnt_create()[2 * part + index - 1];
          int n = k + choiceFunctions.getSelectedIndex();
          var = definitions.get(n);
          def = (Expression) var.R;
          String item = Expression.build(Expression.IS, var, def).printout(false);
          enter.setText(item);
      } else { // on extrait une règle
          int n = choice.getSelectedIndex();
          if (n != -1) {
              enter.setText(choice.getItem(n));
          }
      }
      enter.requestFocus();
  }//GEN-LAST:event_menuExtractActionPerformed

    /**
     * applique une définition (distinguer fonction, schéma ou autre)
     */
  private void menuDefApplyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuDefApplyActionPerformed
      long time = java.lang.System.currentTimeMillis(); // test
      StringTokenizer tk = new StringTokenizer(choiceFunctions.getSelectedItem(), "(");
      String item = tk.nextToken();
      int n = definitions.indexOf(Expression.build(Expression.VAR, item, null));
      if (n == -1) {
          return;
      }
      Expression var = definitions.get(n), def;
      def = (Expression) var.R;
      try {
          Expression e = Parser.parse(enter.getText());
          if (def.op == Expression.FUNC && "schéma".equals(def.L)) { // schéma()
              e = Expression.build(Expression.FUNC, "applique", new Expression[]{e, def});
              e = e.applyDefs(definitions, 0, 50, trace);
          } // appliquer une fonction à une expression avec f->f(x)
          else if (def.op == Expression.EQU && ((Expression) def.L).op == Expression.FUNC
                  && var.L.equals(((Expression) def.L).L)) {
              Expression temp = ((Expression) def.L).copy();
              Expression[] coors = (e.op == Expression.SEQ) ? (Expression[]) e.R : new Expression[]{e};
              if (((Expression[]) temp.R).length == coors.length) {
                  temp.R = coors;
                  e = temp.applyDefs(definitions, 0, 50, trace);
              }
          } else {
              errorDialog.setLabel("ni fonction, ni schéma");
              errorDialog.setVisible(true);
          }
          display(e, false);
          textArea.setText(debug());
          time = java.lang.System.currentTimeMillis() - time; // test
          System.out.println("temps : " + time);
      } catch (Exception ex) {
          textArea.setText(ex.getMessage());
      }
  }//GEN-LAST:event_menuDefApplyActionPerformed


  private void aboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutActionPerformed
      errorDialog.setTitle("A propos");
      errorDialog.setLayout(new FlowLayout());
      errorDialog.setLabel("Auteur : P. Maupou, 2005");
      errorDialog.add(new Label("distribué sous licence GPL"));
      errorDialog.setVisible(true);
  }//GEN-LAST:event_aboutActionPerformed


  private void historyItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_historyItemStateChanged
      enter.setText(history.getSelectedItem());
  }//GEN-LAST:event_historyItemStateChanged

    /**
     * nouvelle définition de la forme f(x)=x^2 ou sch->schéma(x*x->x^2), etc..
     * on les enregistre dans le vecteur definitions. Il faut mettre à jour la
     * liste des fonctions.
     */
  private void menuReplaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuReplaceActionPerformed
      try {
          StringTokenizer sk = new StringTokenizer(enter.getText().trim(), ",");
          while (sk.hasMoreTokens()) {
              Relation relation = (Relation) Parser.parse(sk.nextToken());
              Expression x = (Expression) relation.L;
              if (relation.op != Expression.EQU) {
                  throw new Exception();
              }
              Expression valeur = (Expression) relation.R;
              expression = expression.substitute(x, valeur);
              display(expression, false);
          }
      } catch (Exception e) {
          textArea.setText("Subtitution incorrecte");
      }
  }//GEN-LAST:event_menuReplaceActionPerformed

  private void menuComputeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuComputeActionPerformed
      int s = enter.getSelectionStart();
      int e = enter.getSelectionEnd();
      try {
          if (s < e) {
              Expression[] es = Parser.parse(enter.getText(), s, e);
              Expression dum = Expression.build(Expression.VAR, "dummy", null);
              es[1] = Expression.functionFactory.compute(new Expression[]{es[1]});
              expression = es[0].substitute(dum, es[1]);
          } else {
              expression = Expression.functionFactory.compute(new Expression[]{expression});
          }
          display(expression, false);
      } catch (Exception exception) {
          textArea.setText(" Ne peut calculer l'expression");
      }

  }//GEN-LAST:event_menuComputeActionPerformed

    /**
     * enregistre un fichier html ou un fichier math de définitions
     *
     * @param evt
     */
  private void saveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveActionPerformed
      fileDialog.setTitle("Enregistrer");
      fileDialog.setMode(FileDialog.SAVE);
      if (evt.getSource() == export) {
          fileDialog.setFile("*.math");
      } else {
          if (extension.equals(".html")) {
              fileDialog.setFile(fileName);
          } else {
              fileDialog.setFile("*.html");
          }
      }
      fileDialog.setDirectory(directory);
      fileDialog.setMode(FileDialog.SAVE);
      fileDialog.setLocationRelativeTo(this);
      fileDialog.setVisible(true);
      if (fileDialog.getFile() == null) {
          return;
      }
      fileName = fileDialog.getFile();
      int i = fileName.indexOf(".");
      if (i == -1) {
          fileName = fileName + ".math";
      }
      fileName = fileDialog.getDirectory() + fileName;
      extension = fileName.substring(fileName.lastIndexOf("."));
      File f = new File(fileName);
      String text = "", preApplet = "", postApplet = "";
      if (evt.getSource() == save) { // sauve un fichier html
          if (f.exists() && extension.equals(".html")) { // fichier existant
              try {
                  FileInputStream ins = new FileInputStream(fileName);
                  BufferedReader bf = new BufferedReader(new InputStreamReader(ins));
                  String nextline;
                  while ((nextline = bf.readLine()) != null) {
                      text += nextline + "\n";
                  }
              } catch (IOException exc) {
                  textArea.setText(" Erreur de lecture de fichier : " + exc.toString());
              }
              i = text.indexOf("<APPLET code=\"" + applet.getClass().getName());
              int j = text.indexOf("</APPLET>", i) + 9;
              preApplet = text.substring(0, i);
              postApplet = text.substring(j);
          } else if (extension.equals(".html")) { // nouveau fichier
              preApplet = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n";
              preApplet += "<html>\n<head>\n";
              preApplet += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\">";
              preApplet += "\n<title>Applet HTML Page</title>\n</head>\n";
              preApplet += "<body>\n<P>\n<H3><HR WIDTH=\"100%\">";
              preApplet += "Exercices mathématiques<HR WIDTH=\"100%\"></H3>\n";
              postApplet = "</P>\n</body>\n</html>";
          }
          text = "<APPLET code=\"" + applet.getClass().getName() + ".class\" ";
          text += "width=\"" + applet.getSize().width + "\" ";
          text += "height=\"" + applet.getSize().height + "\">\n";
          text += "<PARAM name=\"archive\" value=\"maths.jar\">\n";
          text += "<PARAM name=\"nombre d'exercices\" value=\"";
          text += applet.getExercices().length + "\">\n";
          if (!imports.isEmpty()) {
              text += "<PARAM name=\"importer\" value=\"\n";
              for (Iterator it = imports.iterator(); it.hasNext();) {
                  Expression def = (Expression) it.next();
                  String name = (String) def.L;
                  if (name.startsWith("'") && name.endsWith("'")) {
                      name = name.substring(1, name.length() - 1);
                  }
                  text += name;
                  if (it.hasNext()) {
                      text += ",\n";
                  }
              }
              text += "\n\">\n";
          }
          String s = defsToString(-1);
          if (!s.equals("")) {
              text += "<PARAM name=\"définitions globales\" value=\"\n";
              text += s + "\n\">\n";
          }
          s = defsToString(-7);
          if (!s.equals("")) {
              text += "<PARAM name=\"décorations\" value=\"\n";
              text += s + "\n\">\n";
          }
          for (i = 0; i < applet.getExercices().length; i++) {
              int num = i + 1;
              text += "<PARAM name=\"Exercice " + num + "\" value=\"\n";
              try {
                  text += exerciceToString(i) + "\">\n";
              } catch (Exception exc) {
                  textArea.setText(" Erreur dans l'exercice " + i + " " + exc.toString());
              }
          }
          text += "</APPLET>";
          text = preApplet + text + postApplet;
      } else if (evt.getSource() == export) { //sauve les définitions globales
          String s;
          if (!imports.isEmpty()) {
              text += "<importer>\n";
              for (Iterator it = imports.iterator(); it.hasNext();) {
                  Expression def = (Expression) it.next();
                  String name = (String) def.L;
                  if (name.startsWith("'") && name.endsWith("'")) {
                      name = name.substring(1, name.length() - 1);
                  }
                  text += name;
                  if (it.hasNext()) {
                      text += ",\n";
                  }
              }
              text += "\n</importer>\n";
          }
          s = defsToString(-1);
          if (!s.equals("")) {
              text += "<definitions>\n";
              text += s + "\n</definitions>\n";
          }
          if (!comments.isEmpty()) {
              text += "<commentaires>\n";
              for (int j = 0; j < comments.size(); j++) {
                  Expression var = comments.get(j);
                  Expression def = (Expression) var.R;
                  text += var.toString() + "->" + def.toString();
                  if (j < comments.size() - 1) {
                      text += ",\n";
                  }
              }
              text += "\n</commentaires>\n";
          }
          if (!decorations.isEmpty()) {
              s = defsToString(-7);
              if (!s.equals("")) {
                  text += "<decorations>\n";
                  text += s + "\n</decorations>\n";
              }
          }
          text += "<history>\n";
          for (i = 0; i < history.getItemCount(); i++) { // et l'historique
              text += history.getItem(i);
              if (i < history.getItemCount() - 1) {
                  text += ",\n";
              } else {
                  text += "\n";
              }
          }
          text += "</history>";
      }
      try {
          FileWriter fileWriter = new FileWriter(fileName);
          fileWriter.write(text);
          fileWriter.close();
      } catch (IOException e) {
          textArea.setText(" Erreur d'écriture d'un fichier : " + e.getMessage());
      }
      if (extension.equals(".html")) {
          setTitle(fileName + " - Mathoscope");
      }
  }//GEN-LAST:event_saveActionPerformed

    /**
     * formate l'exercice de rang n pour l'enregistrer
     *
     * @param n
     * @throws Exception
     * @return
     */
    public String exerciceToString(int n) throws Exception {
        ArrayList<String[]> parts = applet.setExercice(n);
        Expression[] defs;
        int start = 0;
        String ret = "titre : " + applet.choice.getItem(n) + "~\n", listdefs = "";
        for (String[] part1 : parts) {
            String[] elements = (String[]) part1;
            ret += "énoncé :" + Parser.replace(elements[ExpressionApplet.INTRO], "\n", "¶\n") + "~\n";
            try {
                if (!elements[DEFS].equals("{}")) {
                    if (!listdefs.equals("")) {
                        listdefs += ",";
                    }
                    listdefs += elements[ExpressionApplet.DEFS].substring(1, 
                            elements[ExpressionApplet.DEFS].length() - 1);
                    defs = textToList(listdefs);
                    ret += listToString(defs, "définitions : ", start);
                    start = defs.length;
                }
                if (!elements[ExpressionApplet.CHECK].equals("{}")) {
                    if (!listdefs.equals("")) {
                        listdefs += ",";
                    }
                    listdefs += elements[ExpressionApplet.CHECK].substring(1, 
                            elements[ExpressionApplet.CHECK].length() - 1);
                    defs = textToList(listdefs);
                    ret += listToString(defs, "vérification : ", start);
                    start = defs.length;
                }
            } catch (Exception exc) {
                textArea.setText(" échec d'écriture de l'exercice : " + exc.toString());
            }
        }
        return ret;
    }

    /**
     * retourne une liste d'expression
     *
     * @param text
     * @throws Exception
     * @return
     */
    private Expression[] textToList(String text) throws Exception {
        Expression[] ret = new Expression[0];
        if (!text.equals("{}")) {
            Expression listExpr = Parser.parse(text);
            if (listExpr.op == Expression.SEQ && listExpr.R instanceof Expression[]) {
                ret = (Expression[]) listExpr.R;
            } else {
                ret = new Expression[]{listExpr};
            }
        }
        return ret;
    }

    /**
     * formate une liste de définitions
     *
     * @param start le début de la liste
     * @return la chaîne formatée
     */
    private String listToString(Expression[] list, String title, int start) {
        String ret = title, buf = "", next;
        for (int i = start; i < list.length; i++) {
            next = list[i].printout(false);
            if (i < list.length - 1) {
                next += ", ";
            }
            if (buf.length() + next.length() > 90) { // tampon plein
                if (i > start) {
                    ret += "\n   ";
                }
                ret += buf;
                buf = "";
            }
            buf += next;
        }
        return ret + "\n   " + buf + "~\n"; // FIXME : vérifier la correction
    }

    /**
     * ouvre un fichier de définitions ou html avec une applet
     *
     * @param evt le déclencheur
     */
  private void openActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openActionPerformed
      fileDialog.setTitle("Ouvrir");
      fileDialog.setMode(FileDialog.LOAD);
      fileDialog.setDirectory(directory);
      if (evt.getSource() == open) {
          fileDialog.setFile("*.html");
      } else if (evt.getSource() == merge) {
          fileDialog.setFile("*.math");
      }
      fileDialog.setLocationRelativeTo(this);
      fileDialog.setVisible(true);
      fileName = fileDialog.getFile();
      if (fileName == null) {
          return;
      }
      directory = fileDialog.getDirectory();
      extension = fileName.substring(fileName.lastIndexOf("."));
      history.removeAll();
      Expression[] defs;
      try {
          if (evt.getSource() == merge) { //importer un fichier de définitions
              String s = (applet.getPartie() == -1) ? "" : " Exercice en cours annulé";
              applet.setPartie(-1);
              int n = applet.getDefinitions().size();
              applet.getDefinitions().subList(applet.getCnt_create()[0], n).clear();
              n = definitions.size();
              definitions.subList(applet.getCnt_create()[0], n).clear();
              textArea.setText(s.replace('¶', '\n'));
              applet.initGraph(null);
              if (htmlDir != null && directory.indexOf(htmlDir) == 0) {
                  s = directory.substring(htmlDir.length());
                  fileName = s + fileName;
                  directory = directory.substring(0, htmlDir.length());
              }
              fileName = fileName.replace('\\', '/');
              String context = "file:\\" + directory;
              getImportDefs(context, fileName);
              String text = "", nextline;
              URL url = new URL(context + fileName);
              BufferedReader bf = new BufferedReader(new InputStreamReader(url.openStream()));
              while ((nextline = bf.readLine()) != null) {
                  text += nextline;
              }
              int d0 = text.indexOf("<history>");
              int d1 = text.indexOf("</history>", d0);
              s = text.substring(d0 + 9, d1).trim();
              if (!s.equals("")) {
                  defs = (Expression[]) Parser.parse(s).R;
                  for (Expression def : defs) {
                      history.add(def.printout(false));
                  }
              }
              d0 = text.indexOf("<commentaires>");
              d1 = text.indexOf("</commentaires>", d0);
              if (d0 != -1) {
                  s = "{" + text.substring(d0 + 14, d1) + "}";
                  if (!"{}".equals(s)) {
                      defs = (Expression[]) Parser.parse(s).R;
                      comments = new ArrayList<Expression>();
                      for (Expression def : defs) {
                          Expression f = (Expression) def.L;
                          f.R = (Expression) def.R;
                          comments.add(f);
                      }
                  }
              }
              htmlDir = directory;
          } else if (evt.getSource() == open) { // fichier html contenant une applet
              htmlDir = directory;
              fileName = directory + fileName;
              String text = "", nextline;
              FileInputStream ins = new FileInputStream(fileName);
              BufferedReader bf = new BufferedReader(new InputStreamReader(ins));
              while ((nextline = bf.readLine()) != null) {
                  text += nextline;
              }
              choice.removeAll();
              choiceFunctions.removeAll();
              definitions = new ArrayList<Expression>();
              decorations = new ArrayList<Expression>();
              imports = new ArrayList<Expression>();
              applet.reset();
              getAppletParams(text);
          }
          updateChoiceDefs("", -1, 0);
      } catch (Exception e) {
          textArea.setText(" Echec d'ouverture du fichier : " + e.toString());
      }
      if (extension.equals(".html")) {
          setTitle(fileName + " - Mathoscope");
      } else {
          fileName = "*" + extension;
      }
      validate();
  }//GEN-LAST:event_openActionPerformed

    /**
     * entrée d'une expression dans le champ texte, elle est conservée dans la
     * variable expression et affichée
     *
     */
  private void enterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_enterActionPerformed
      String entrytext = enter.getText();
      try {
          expression = Parser.parse(entrytext);
          entrytext = expression.printout(false);
          enter.setText(entrytext);
          history.insert(entrytext, 0);
          if (history.getItemCount() > 20) {
              history.remove(history.getItemCount() - 1);
          }
          enter.setCaretPosition(enter.getText().length());
          applet.runner = null;
          applet.initGraph(null);
          Expression.functionFactory.setActive(false);
          applet.drawExpression(expression, 0, 0, false);
      } catch (Exception e) {
          errorDialog.setTitle("Erreur de syntaxe");
          // e.printStackTrace();
          errorDialog.setLabel(e.getMessage());
          errorDialog.setVisible(true);
      }
      Expression.functionFactory.setActive(true);
  }//GEN-LAST:event_enterActionPerformed

  private void enterKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_enterKeyPressed
      int kcode = evt.getKeyCode(), i = enter.getCaretPosition(), shift = 1;
      String s = String.valueOf(evt.getKeyChar());
      String before = enter.getText().substring(0, i);
      String after = enter.getText().substring(i);
      boolean modified = true;
      if (evt.getKeyChar() == '*') {
          s = "×";
      } else if (evt.getKeyChar() == '(' || (kcode == 52 && evt.getModifiers() == 10)) {
          s = (evt.getKeyChar() == '(') ? "()" : "{}";
          int start = enter.getSelectionStart(), end = enter.getSelectionEnd();
          if (start < end) {
              before = enter.getText().substring(0, start);
              after = enter.getText().substring(end);
              s = s.substring(0, 1) + enter.getText().substring(start, end) + s.substring(1);
          }
      } else if (evt.getModifiers() == 10 && kcode == KeyEvent.VK_E) {
          s = "";
      } else if (evt.getModifiers() == 2) {// CTRL
          if (kcode == 72) { // h
              history.requestFocus();
              evt.consume();
          } else if (kcode == KeyEvent.VK_P) { // p
              try {
                  System.out.println(Parser.parse(enter.getText()).toString());
                  evt.consume();
              } catch (Exception exc) {
                  textArea.setText(" Pas d'expression");
              }
          }
          return;
      } else if (evt.getModifiers() == 8) {// ALT
          if (kcode == KeyEvent.VK_R) {
              s = "rac()";
              shift = 4;
          } else if (kcode == KeyEvent.VK_E) {
              s = "entrée";
              shift = 6;
          } else if (kcode == KeyEvent.VK_F) {
              s = "format->";
              shift = 8;
          } else if (kcode == KeyEvent.VK_A) {
              s = "applique()";
              shift = 9;
          } else if (kcode == KeyEvent.VK_Q) {
              s = "question";
              shift = 8;
          } else if (kcode == KeyEvent.VK_S) {
              s = "solution";
              shift = 8;
          } else if (kcode == KeyEvent.VK_K) {
              s = "correct->";
              shift = 9;
          } else if (kcode == KeyEvent.VK_V) {
              s = "vec()";
              shift = 4;
          } else if (kcode == KeyEvent.VK_C) { // c
              s = "calcule()";
              shift = 8;
          } else if (kcode == KeyEvent.VK_I) { // i
              s = "inter";
              shift = 5;
          } else if (kcode == KeyEvent.VK_U) {
              s = "union";
              shift = 5;
          } else if (kcode == KeyEvent.VK_NUMPAD0) { // 0
              s = "Ø";
          } else {
              modified = false;
          }
      } else {
          modified = false;
      }
      if (modified) {
          evt.consume();
          enter.setText(before + s + after);
          enter.setCaretPosition(i + shift);
      }
  }//GEN-LAST:event_enterKeyPressed

  private void quitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitActionPerformed
      System.exit(0);
  }//GEN-LAST:event_quitActionPerformed

    /**
     * Exit the Application
     */
  private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
      System.exit(0);
  }//GEN-LAST:event_exitForm

    /**
     * écrit le texte des opérations
     */
    private String debug() {
        String text = "", s, indent = "";
        if (trace != null) {
            for (int i = 0; i < trace.size(); i += 2) {
                Expression next = trace.get(i);
                s = next.printout(false);
                if (s.startsWith("`") && s.endsWith("`")) {
                    s = s.substring(1, s.length() - 1);
                }
                next = trace.get(i + 1);
                if ("valeur :".equals(s) && indent.length() >= 2) {
                    indent = indent.substring(2);
                }
                text += indent + s + "  " + next.printout(false) + "\n";
                if ("fonction :".equals(s) || "variables :".equals(s)) {
                    indent += "  ";
                }
            }
            trace.clear();
        }
        return text;
    }

    /**
     * actualise la partie actuelle de l'exercice en cours dans la chaîne
     * exercice[]
     */
    public void updatePart() {
        if (status || part < 0) {
            if (status) {
                errorDialog.setLabel("mode création uniquement");
                errorDialog.setVisible(true);
            }
            return;
        }
        int n = applet.getNumero(), p = applet.getPartie();
        String[] params = applet.getParameters().get(p);
        StringTokenizer tk = new StringTokenizer(params[ExpressionApplet.MARKS]);
        int start = Integer.parseInt(tk.nextToken());
        String intro = params[ExpressionApplet.INTRO].replace('\n', '¶');
        String newPart = "énoncé :" + intro + "~";
        newPart += "définitions :" + defsToString(2 * p) + "~";
        newPart += "vérification :" + defsToString(2 * p + 1) + "~";
        // pour remplacer la chaîne dans exercice
        String textEx = applet.getExercices()[n];
        String s = textEx.substring(0, start) + newPart;
        if (p < applet.getParameters().size() - 1) {
            params = applet.getParameters().get(p + 1);
            tk = new StringTokenizer(params[ExpressionApplet.MARKS]);
            start = Integer.parseInt(tk.nextToken()); // début de la partie suivante
            s += textEx.substring(start);
        }
        try {
            applet.getExercices()[n] = s;
            applet.setParameters(applet.setExercice(n));
        } catch (Exception e) {
            textArea.setText(" Erreur de mise à jour de la partie en cours de l'exercice.");
        }
    }

    /**
     * @param n pointe sur la partie concernée
     * @return la chaîne de définitions
     */
    private String defsToString(int n) {
        String ret = "";
        AbstractList<Expression> curdefs = (n == -7) ? decorations : definitions;
        int start = 0, nb = decorations.size();
        if (n > -1) {
            start = applet.getCnt_create()[n];
        }
        if (n > -7) {
            nb = applet.getCnt_create()[n + 1] - start;
        }
        Expression[] defs = new Expression[nb];
        nextdef:
        for (int i = 0; i < nb; i++) {
            defs[i] = (Expression) curdefs.get(start + i);
            Expression def = defs[i], expvar;
            if (def.op == Expression.VAR) {
                try {
                    expvar = Parser.parse((String) def.L); // on interprète la variable si possible
                } catch (Exception ex) {
                    expvar = def;
                }
                def = Expression.build(Expression.IS, expvar, def.R);
            }
            if (n < 0 && !imports.isEmpty()) {// tenir compte des définitions importées
                for (Iterator it = imports.iterator(); it.hasNext();) {
                    Expression elem = (Expression) ((Expression) it.next()).R;
                    Expression[] importDefs = (Expression[]) elem.R;
                    for (Expression importDef : importDefs) {
                        if (importDef.equals(def)) {
                            continue nextdef;
                        }
                    }
                }
            }
            ret += def.printout(false);
            if (i != nb - 1) {
                ret += (n < 0) ? ",\n" : ", ";
            }
        }
        if (ret.endsWith(",\n")) {
            ret = ret.substring(0, ret.length() - 2);
        }
        return ret;
    }

    /**
     * actualise la boîte "choice" des règles suivant l'élément sélectionné
     *
     * @param definitions liste contenant la liste des définitions
     */
    private void updateChoice(AbstractList definitions) {
        choice.removeAll();
        String deftext = choiceFunctions.getSelectedItem();
        if (deftext == null) {
            return;
        }
        StringTokenizer tk = new StringTokenizer(deftext, "(");
        Expression def = Expression.var(tk.nextToken()), toprint;
        int index = choiceParam.getSelectedIndex(), start = 0, end = definitions.size();
        if (index == COMMENTS) {
            index = GDEFS;
        }
        if (!status && index < 7) {
            int rg = (index == GDEFS) ? -1 : 2 * part + index - 1;
            start = (rg == -1) ? 0 : applet.getCnt_create()[rg];
            end = applet.getCnt_create()[rg + 1];
        }
        int n = definitions.subList(start, definitions.size()).indexOf(def);
        if (n == -1 || n >= end - start) { // ce n'est pas la définition d'une variable
            n = -1;
            try {
                Expression edef = Parser.parse(deftext);
                edef = Expression.build(Expression.IS, edef, Expression.var("image"));
                for (int i = 0; i < definitions.size(); i++) {
                    Expression next = (Expression) definitions.get(i);
                    if (next.op == Expression.SET) {
                        Expression[] elems = (Expression[]) next.R;
                        for (Expression elem : elems) {
                            if (elem.equals(edef)) {
                                n = i;
                                break;
                            }
                        }
                    }
                }
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }
        if (n == -1) {
            return;
        }
        def = (Expression) definitions.get(n + start);
        if (def.op == Expression.VAR) {
            def = (Expression) def.R;
        }
        if (def.op == Expression.EQU && ((Expression) def.L).toString().equals(deftext)) {
            def = (Expression) def.R; // par exemple f(x)=2*x donne 2*x
        }
        if (def.op == Expression.SEQ || "schéma".equals(def.L) || "applique".equals(def.L)) {
            Expression[] newrules = (Expression[]) def.R;
            for (Expression newrule : newrules) {
                toprint = newrule;
                if (index == 8 && toprint.op == Expression.IS) {
                    toprint = (Expression) newrule.L;
                }
                choice.add(toprint.printout(false));
            }
            if ("schéma".equals(def.L) || "applique".equals(def.L)) {
                listRules.setText("Règles :");
            } else {
                listRules.setText("Eléments :");
            }
        } else if (!deftext.equals(def.printout(false))) {
            choice.add(def.printout(false));
            if (def.op == Expression.FUNC) {
                listRules.setText("Fonction :");
            } else if (def.op == Expression.EQU && ((Expression) def.L).op == Expression.FUNC) {
                listRules.setText("Fonction :");
            } else {
                listRules.setText("Définition :");
            }
        }
    }

    /**
     * actualise la boîte des définitions
     *
     * @param partie
     * @param type global:0, local:1, commentaires:6, décorations:7, imports:8
     * @param selected l'item sélectionné ou la fin de la liste
     * @throws Exception
     */
    public void updateChoiceDefs(String selected, int partie, int type) throws Exception {
        part = partie;
        String oldSelected = choiceFunctions.getSelectedItem();
        choiceFunctions.removeAll();
        choiceParam.select(type);
        AbstractList defs = (status) ? applet.getDefinitions() : definitions;
        if (type == DECOS) {
            defs = decorations;
        } else if (type == IMPORTS) {
            defs = imports;
        }
        int start = 0, end = defs.size();
        if (type == GDEFS || type == COMMENTS) {
            end = applet.getCnt_create()[0];
        } else if (status && type < 7) {
            start = applet.getCnt_create()[0];
        } else if (type < 7) { // mode création et définitions locales
            if (part == -1) {
                return;
            }
            start = applet.getCnt_create()[2 * partie + type - 1];
            end = applet.getCnt_create()[2 * partie + type];
        }
        for (int i = start; i < end; i++) {
            Expression var = (Expression) defs.get(i);
            if (var.op == Expression.VAR) {
                String name = (String) var.L;
                if (var.R != null) {
                    Expression def = (Expression) var.R;
                    if (def.op == Expression.FUNC && name.equals(def.L)) // f(x)
                    {
                        name = def.printout(false); // f(x)
                    } else if (def.op == Expression.EQU) { // f(x) = x+1
                        Expression form = (Expression) def.L;
                        if (name.equals(form.L)) {
                            name = form.printout(false);
                        }
                    }
                }
                choiceFunctions.add(name);
            } else if (var.op == Expression.SET) {
                Expression[] coors = (Expression[]) var.R;
                for (Expression coor : coors) {
                    if (coor.op == Expression.IS && coor.R.equals(Expression.var("image"))) {
                        String name = ((Expression) coor.L).printout(false);
                        choiceFunctions.add(name);
                    }
                }
            }
        }
        if (status && oldSelected != null) {
            selected = oldSelected;
        }
        if (!selected.equals("")) {
            choiceFunctions.select(selected);
        }
        updateChoice(defs);
    }

    /**
     * ajoute ou remplace une définition dans une partie de la liste definitions
     *
     * @param part le rang de la partie des définitions concernée
     * @param def l'expression de la définition à ajouter
     * @param before la chaîne de la définition précédente
     * @throws Exception
     * @return le nom de la définition
     */
    public String addDefinition(Expression def, int part, String before) throws Exception {
        Expression newdef = def;
        if (def.op == Expression.IS) { // définition
            newdef = (Expression) def.L;
            if (newdef.op == Expression.SET && "{}".equals(newdef.L) 
                    || newdef.op == Expression.SEQ) { // définition multiple
                String listv = (newdef.op == Expression.SET) ? "{" : "";
                Expression[] newset = (Expression[]) newdef.R;
                for (Expression nset : newset) {
                    if (nset.op == Expression.VAR) {
                        listv += (String) nset.L + ",";
                    } else {
                        throw new Exception("définition multiple non valide");
                    }
                }
                listv = listv.substring(0, listv.lastIndexOf(','));
                if (newdef.op == Expression.SET) {
                    listv += "}";
                }
                newdef = Expression.build(Expression.VAR, listv, def.R);
            } else if (newdef.op == Expression.VAR) { // variable simple
                newdef.R = def.R;
            } else {
                throw new Exception("ni variable ni ensemble à définir");
            }
        } else if (def.op == Expression.VAR) { // ne passe jamais
            newdef.R = Expression.build(Expression.FUNC, "schéma", new Expression[0]);
        } else if (!(def.op == Expression.SET && def.R instanceof Expression[])) {
            throw new Exception("définition non valide");
        }
        addObj(newdef, part, before);
        if (newdef.op == Expression.SET) {
            Expression[] coors = (Expression[]) def.R;
            for (Expression coor : coors) {
                if (coor.op == Expression.IS && Expression.var("image").equals(coor.R)) {
                    return ((Expression) coor.L).printout(false);
                }
            }
            throw new Exception("définition non valide");
        }
        String ret = (String) newdef.L; // FIXME : on doit obtenir la chaîne qui apparaît dans la boîte
        newdef = (Expression) newdef.R;
        if (newdef.op == Expression.EQU) {
            ret = ((Expression) newdef.L).printout(false); // f->f(x)=x^2, on prend f(x)
        } else if (newdef.op == Expression.FUNC && ret.equals(newdef.L)) // f->f(x)
        {
            ret = newdef.printout(false);
        }
        return ret;
    }

    /**
     * ajoute ou remplace un objet dans une liste
     *
     * @param before le nom de la définition qui devrait précéder dans la liste
     * @param obj la définition à insérer
     * @param part -1 pour une définition globale, sinon le rang de la partie en
     * cours
     */
    private void addObj(Expression e, int part, String before) {
        AbstractList<Expression> curDefs = (part == -7) ? decorations : definitions;
        int[] cnt_create = applet.getCnt_create();
        int start = 0, end = curDefs.size();
        if (part > -7) {
            end = cnt_create[part + 1];
        }
        if (part > -1) {
            start = cnt_create[part]; // définitions locales
        }
        int n = curDefs.subList(start, curDefs.size()).indexOf(e);
        if (n != -1) {
            n += start;
        }
        if (n < start || n >= end) { // n'est pas encore dans la liste
            int index = curDefs.subList(start, curDefs.size()).indexOf(Expression.var(before));
            if (index != -1 && index < end - start) {
                end = index + start + 1;
            }
            curDefs.add(end, e);
            for (int i = part + 1; -1 < i && i < cnt_create.length; i++) {
                cnt_create[i]++;
            }
        } else {
            curDefs.set(n, e);
        }
    }

    /**
     * enlève une définition de la liste
     */
    private String removeDefinition(int n, int part, String before) {
        int[] cnt_create = applet.getCnt_create();
        int start = 0, end = cnt_create[part + 1];
        if (part > -1) {
            start = cnt_create[part]; // définitions locales
        }
        if (n <= end - start) {
            definitions.remove(n + start);
            for (int i = part + 1; i < cnt_create.length; i++) {
                cnt_create[i]--;
            }
        }
        return before;
    }

    /**
     * insère un élément dans une boîte de choix après l'élément sélectionné
     *
     * @param s la chaîne à insérer
     * @param choice la boîte de choix
     * @return
     */
    private int choiceInsert(String s, Choice choice) {
        int n = choice.getSelectedIndex();
        n = (n < 0) ? choice.getItemCount() : n + 1;
        choice.insert(s, n);
        return n;
    }

    /**
     * établit un schéma des règles existant dans choice
     */
    private Expression[] setRules() throws Exception {
        int n = choice.getItemCount();
        Expression[] Rules = new Expression[n];
        for (int i = 0; i < n; i++) {
            Rules[i] = Parser.parse(choice.getItem(i));
        }
        return Rules;
    }

    /**
     * dessine l'expression et l'écrit dans le champ texte
     *
     * @param isFigure
     */
    private void display(Expression expression, boolean isFigure) {
        enter.setCaretPosition(0);
        if (!isFigure) {
            enter.setText(expression.printout(false));
        }
        applet.drawExpression(expression, 0, 0, isFigure);
    }

    /**
     * ajoute des définitions et des décorations à partir d'un fichier *.math
     *
     * @param context le chemin du fichier
     * @param fileName le nom du fichier
     * @throws java.lang.Exception
     */
    private void getImportDefs(String context, String fileName) throws Exception {
        StringBuffer defsbuf = new StringBuffer(), decosbuf = new StringBuffer();
        imports.addAll(applet.getImports(context, fileName, defsbuf, decosbuf, htmlDir == null));
        if (defsbuf.length() > 0) {
            Expression listdefs = Parser.parse(defsbuf.toString());
            Expression[] defs = new Expression[]{listdefs};
            if (listdefs.R instanceof Expression[]) {
                defs = (Expression[]) listdefs.R;
            }
            for (Expression def : defs) {
                addDefinition(def, -1, "");
                def.define(applet.getDefinitions(), false);
            }
        }
        if (decosbuf.length() > 0) {
            Expression listdefs = Parser.parse(decosbuf.toString());
            Expression[] defs;
            if (listdefs.R instanceof Expression[]) {
                defs = (Expression[]) listdefs.R;
            }
            defs = (Expression[]) listdefs.R;
            for (Expression f : defs) {
                if (f.op == -1) {
                    f = (Expression) f.L;
                }
                int k = decorations.indexOf(f);
                if (k == -1) {
                    decorations.add(f);
                } else {
                    decorations.set(k, f);
                }
            }
            applet.setDecorations(decorations);
        }
    }

    /**
     * lit une page html et extrait les exercices de la première applet
     *
     * @param text le tampon de lecture
     */
    private void getAppletParams(String text) {
        int type, nbexos = -1, width = applet.getSize().width, height = applet.getSize().height;
        String last = "", name = "";
        String defs = "", decos = "", intro = "";
        String[] exercices = new String[0];
        boolean inApplet = false, inTag = false, inParam = false, inAttr = false;
        try {
            StreamTokenizer tk = new StreamTokenizer(new StringReader(text));
            tk.wordChars('/', '/');
            tk.wordChars('!', '!');
            tk.wordChars(39, 39);
            tk.eolIsSignificant(false); // fin de ligne devient espacement
            while ((type = tk.nextToken()) != StreamTokenizer.TT_EOF) {
                switch (type) {
                    case '<': // début de tag
                        inTag = true;
                        break;
                    case '>': // fin de tag
                        inTag = false;
                        inParam = false;
                        break;
                    case '=': // début d'attribut
                        inAttr = true;
                        break;
                    case StreamTokenizer.TT_WORD:
                        last = tk.sval;
                        if (!inTag) {
                            break;
                        }
                        last = last.toLowerCase();
                        if (last.equals("applet")) {
                            inApplet = true;
                        } else if (last.equals("/applet")) {
                            inApplet = false;
                        } else if (last.equals("param") && inApplet) {
                            inParam = true;
                        }
                        break;
                    case '"':
                        if (!inApplet || !inAttr) {
                            break;
                        }
                        if (last.equals("code")) {
                            String className = applet.getClass().getName() + ".class";
                            inApplet = className.equals(tk.sval);
                        } else if (last.equals("width")) {
                            width = Integer.parseInt(tk.sval);
                        } else if (last.equals("height")) {
                            height = Integer.parseInt(tk.sval);
                        }
                        if (!inParam) {
                            break;
                        }
                        if (last.equals("name")) {
                            name = tk.sval;
                        } else if (last.equals("value")) {
                            if (name.equals("présentation")) {
                                intro = tk.sval;
                            } else if (name.equals("importer")) {
                                StringBuffer defsbuf = new StringBuffer();
                                StringBuffer decosbuf = new StringBuffer();
                                String context = "file:\\" + directory;
                                imports = applet.getImports(context, tk.sval, defsbuf, decosbuf, false);
                                defs = defsbuf.toString();
                                decos = decosbuf.toString();
                            } else if (name.equals("définitions globales")) {
                                defs = (defs.equals("")) ? tk.sval : defs + "," + tk.sval;
                            } else if (name.equals("décorations")) {
                                decos = (decos.equals("")) ? tk.sval : decos + "," + tk.sval;
                            } else if (name.equals("nombre d'exercices")) {
                                nbexos = Integer.parseInt(tk.sval);
                                exercices = new String[nbexos];
                            } else if (name.startsWith("Exercice") && nbexos != -1) {
                                int num = Integer.parseInt(name.substring(9));
                                if (num <= nbexos) {
                                    exercices[num - 1] = Parser.replace(tk.sval, "¶", "¶\n");
                                    exercices[num - 1] = Parser.replace(exercices[num - 1], "~", "~\n");
                                }
                            }
                        }
                        inAttr = false;
                }
            }
            int w = width - applet.getSize().width, h = height - applet.getSize().height;
            setVisible(false);
            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
            w += getSize().width;
            h += getSize().height;
            setBounds((screenSize.width - w) / 2, (screenSize.height - h) / 2, w, h);
            setVisible(true);
            applet.loadExercices(exercices, intro, defs, decos);
            decorations = applet.decorations;
            choice.removeAll();
            applet.initGraph(null);
            definitions = new ArrayList<Expression>();
            if (!"".equals(defs)) {
                Expression[] edefs = (Expression[]) Parser.parse("{" + defs + "}").R;
                for (Expression edef : edefs) {
                    addDefinition(edef, -1, "");
                }
            }
        } catch (Exception IOE) {
            textArea.setText("Erreur de chargement de l'applet : " + IOE.toString());
        }
        applet.initExercise();
    }

    /**
     * supprime les définitions particulières aux exercices
     */
    public void initDefinitions() {
        if (applet.getCnt_create()[0] < definitions.size()) {
            definitions.subList(applet.getCnt_create()[0], definitions.size()).clear();
        }
        part = 0;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        new MathFrame().setVisible(true);
    }

    /**
     * Setter pour expression.
     *
     * @param expression la nouvelle valeur à afficher
     */
    public void setExpression(expressions.Expression expression) {
        this.expression = expression;
    }

    /**
     * Getter for property status.
     *
     * @return true si le mode est exercice, faux si le mode est création
     */
    public boolean isStatus() {
        return status;
    }

    /**
     * Setter for property status.
     *
     * @param status New value of property status.
     */
    public void setStatus(boolean status) {
        this.status = status;
    }

    /**
     * Getter for property definitions.
     *
     * @return Value of property definitions.
     */
    public ArrayList<Expression> getDefinitions() {
        return definitions;
    }

    /**
     * Setter for property definitions.
     *
     * @param definitions New value of property definitions.
     */
    public void setDefinitions(java.util.ArrayList<Expression> definitions) {
        this.definitions = definitions;
    }

    /**
     * Setter for property typedefs.
     *
     * @param typedefs New value of property typedefs.
     */
    public void setTypedefs(int typedefs) {
        this.typedefs = typedefs;
        choiceParam.select(typedefs);
    }

    public java.awt.Choice getHistory() {
        return history;
    }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  java.awt.MenuItem New;
  java.awt.MenuItem about;
  java.awt.Menu actions;
  java.awt.MenuItem aide;
  java.awt.CheckboxMenuItem cheatMenu;
  java.awt.Choice choice;
  public java.awt.Choice choiceFunctions;
  public java.awt.Choice choiceParam;
  java.awt.Checkbox create;
  java.awt.CheckboxMenuItem debugMenu;
  java.awt.TextField enter;
  java.awt.CheckboxMenuItem enterGPanel;
  java.awt.Checkbox execute;
  java.awt.MenuItem export;
  java.awt.Menu files;
  private java.awt.Choice history;
  java.awt.Menu infos;
  java.awt.Label listLabels;
  java.awt.Label listRules;
  java.awt.Menu menuAdd;
  java.awt.MenuItem menuAddDef;
  java.awt.MenuItem menuAddExercise;
  java.awt.MenuItem menuAddPartie;
  java.awt.MenuItem menuAddRule;
  java.awt.Menu menuApply;
  java.awt.MenuItem menuApplyDef;
  java.awt.MenuItem menuApplyDefs;
  java.awt.MenuBar menuBar;
  java.awt.MenuItem menuCompute;
  java.awt.MenuItem menuDelete;
  java.awt.MenuItem menuExtractDef;
  java.awt.MenuItem menuInitialize;
  java.awt.MenuItem menuNext;
  java.awt.Menu menuParts;
  java.awt.MenuItem menuPrevious;
  java.awt.MenuItem menuReplace;
  java.awt.MenuItem menuRuleModify;
  java.awt.MenuItem merge;
  java.awt.CheckboxGroup modesGroup;
  java.awt.MenuItem open;
  java.awt.MenuItem palette;
  java.awt.Panel panelEnter;
  java.awt.Panel panelNorth;
  java.awt.Panel panelRules;
  java.awt.Label param_name;
  java.awt.MenuItem quit;
  java.awt.Menu rules;
  java.awt.MenuItem save;
  java.awt.TextArea textArea;
  // End of variables declaration//GEN-END:variables
  private Expression expression;
    private boolean status = false, hide = false;
    public MathDialog errorDialog;
    private FileDialog fileDialog;
    private String fileName, directory, htmlDir, extension, definition;
    public String saveText;
    private int typedefs, part;
    public ArrayList<Expression> comments, imports, decorations;
    public ArrayList<Expression> definitions;
    private ArrayList<Expression> trace;
    private static final int GDEFS = 0, DEFS = 1, CHECKS = 2, TITLE = 3,
            TOTAL = 4, TEXT = 5, COMMENTS = 6, DECOS = 7, IMPORTS = 8;
    public ExpressionApplet applet;

}
